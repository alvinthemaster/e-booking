import 'package:flutter/foundation.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/booking_models.dart';
import '../services/firebase_booking_service.dart';

class BookingProvider with ChangeNotifier {
  final FirebaseBookingService _bookingService = FirebaseBookingService();
  final FirebaseAuth _auth = FirebaseAuth.instance;

  List<Booking> _bookings = [];
  List<Booking> _filteredBookings = [];
  List<Route> _routes = [];
  List<Van> _vans = [];
  bool _isLoading = false;
  String _searchQuery = '';
  String? _errorMessage;

  List<Booking> get bookings => _filteredBookings;
  List<Route> get routes => _routes;
  List<Van> get vans => _vans;
  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;
  String? get errorMessage => _errorMessage;

  /// Load user's bookings from Firebase
  Future<void> loadBookings() async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final user = _auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      _bookings = await _bookingService.getUserBookings(user.uid);
      _filteredBookings = List.from(_bookings);
      _applySearch();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error loading bookings: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Load available routes from Firebase
  Future<void> loadRoutes() async {
    try {
      _routes = await _bookingService.getAvailableRoutes();
      notifyListeners();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error loading routes: $e');
      notifyListeners();
    }
  }

  /// Create a new booking
  Future<String> createBooking({
    required String routeId,
    required String routeName,
    required String origin,
    required String destination,
    required DateTime departureTime,
    required List<String> seatIds,
    required double basePrice,
    required double discountAmount,
    required double totalAmount,
    required String paymentMethod,
    Map<String, dynamic>? passengerDetails,
  }) async {
    try {
      _isLoading = true;
      _errorMessage = null;
      notifyListeners();

      final user = _auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      // Check seat availability
      final seatsAvailable = await _bookingService.areSeatsAvailable(routeId, seatIds);
      if (!seatsAvailable) {
        throw Exception('One or more selected seats are no longer available');
      }

      final booking = Booking(
        id: '', // Will be generated by Firebase
        userId: user.uid,
        userName: user.displayName ?? 'User',
        userEmail: user.email ?? '',
        routeId: routeId,
        routeName: routeName,
        origin: origin,
        destination: destination,
        departureTime: departureTime,
        bookingDate: DateTime.now(),
        seatIds: seatIds,
        numberOfSeats: seatIds.length,
        basePrice: basePrice,
        discountAmount: discountAmount,
        totalAmount: totalAmount,
        paymentMethod: paymentMethod,
        paymentStatus: PaymentStatus.pending,
        bookingStatus: BookingStatus.active,
        passengerDetails: passengerDetails,
      );

      final bookingId = await _bookingService.createBooking(booking);

      // Reload bookings to reflect the new booking
      await loadBookings();

      return bookingId;
    } catch (e) {
      _errorMessage = e.toString();
      notifyListeners();
      throw Exception('Failed to create booking: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Cancel booking
  Future<void> cancelBooking(String bookingId) async {
    try {
      _isLoading = true;
      _errorMessage = null;
      notifyListeners();

      await _bookingService.cancelBooking(bookingId);

      // Reload bookings to reflect the cancellation
      await loadBookings();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error cancelling booking: $e');
      notifyListeners();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Update payment status
  Future<void> updatePaymentStatus(String bookingId, PaymentStatus status) async {
    try {
      await _bookingService.updatePaymentStatus(bookingId, status);

      // Update local booking
      final bookingIndex = _bookings.indexWhere((b) => b.id == bookingId);
      if (bookingIndex != -1) {
        // Reload bookings to get updated data
        await loadBookings();
      }
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error updating payment status: $e');
      notifyListeners();
    }
  }

  /// Search bookings
  void searchBookings(String query) {
    _searchQuery = query;
    _applySearch();
    notifyListeners();
  }

  void _applySearch() {
    if (_searchQuery.isEmpty) {
      _filteredBookings = List.from(_bookings);
    } else {
      _filteredBookings = _bookings.where((booking) {
        return booking.userName.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               booking.userEmail.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               booking.origin.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               booking.destination.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               booking.routeName.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               booking.id.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               (booking.eTicketId?.toLowerCase().contains(_searchQuery.toLowerCase()) ?? false);
      }).toList();
    }
  }

  /// Get booking by ID
  Future<Booking?> getBookingById(String bookingId) async {
    try {
      return await _bookingService.getBookingById(bookingId);
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error getting booking: $e');
      notifyListeners();
      return null;
    }
  }

  /// Check if seats are available
  Future<bool> areSeatsAvailable(String routeId, List<String> seatIds) async {
    try {
      return await _bookingService.areSeatsAvailable(routeId, seatIds);
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error checking seat availability: $e');
      notifyListeners();
      return false;
    }
  }

  /// Initialize sample data (for testing)
  Future<void> initializeSampleData() async {
    try {
      await _bookingService.initializeSampleData();
      // Load routes without notifyListeners to avoid setState during build
      _routes = await _bookingService.getAvailableRoutes();
      debugPrint('Sample data initialized successfully');
      notifyListeners();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error initializing sample data: $e');
      notifyListeners();
    }
  }

  /// Initialize sample data silently (without notifyListeners)
  Future<void> initializeSampleDataSilent() async {
    try {
      await _bookingService.initializeSampleData();
      // Load routes without notifyListeners to avoid setState during build
      _routes = await _bookingService.getAvailableRoutes();
      debugPrint('Sample data initialized successfully');
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error initializing sample data: $e');
    }
  }

  /// Clear error message
  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  /// Van Management Methods

  /// Load active vans from Firebase
  Future<void> loadVans() async {
    try {
      debugPrint('üîç Loading vans from Firestore...');
      _isLoading = true;
      notifyListeners();
      
      // Clear existing vans first to avoid showing stale data
      _vans.clear();
      
      final loadedVans = await _bookingService.getActiveVans();
      debugPrint('üìÑ Loaded ${loadedVans.length} vans from Firestore');
      
      // Debug print to see loaded vans
      for (var van in loadedVans) {
        debugPrint('üöê Van: ${van.plateNumber} - Driver: ${van.driver.name} - Raw Status: "${van.status}" - Display: "${van.statusDisplay}" - Queue: ${van.queuePosition} (${van.currentOccupancy}/${van.capacity})');
      }
      
      _vans = loadedVans;
      _isLoading = false;
      debugPrint('‚úÖ Successfully loaded ${_vans.length} vans from Firestore');
      
      notifyListeners();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error loading vans: $e');
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Initialize sample van data
  Future<void> initializeSampleVans() async {
    try {
      debugPrint('üîç Checking if vans already exist in Firestore...');
      
      // First check if any vans exist in Firestore
      final existingVans = await _bookingService.getActiveVans();
      
      if (existingVans.isNotEmpty) {
        debugPrint('‚úÖ Found ${existingVans.length} existing vans in Firestore, skipping sample data creation');
        return; // Don't create sample data if real vans exist
      }
      
      debugPrint('üìù No vans found, checking if sample data should be created...');
      
      // Only create sample data if explicitly needed for development
      // In production, this should be disabled
      const bool shouldCreateSampleVans = false; // Set to false to prevent sample data
      
      if (!shouldCreateSampleVans) {
        debugPrint('‚è≠Ô∏è Sample van creation disabled');
        return;
      }
      
      // Sample van creation code here (only runs if enabled)
      debugPrint('üìù Creating sample van data...');
      await _bookingService.initializeSampleVans();
      await loadVans();
      debugPrint('‚úÖ Sample vans initialized successfully');
      
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error initializing sample vans: $e');
    }
  }

  /// Initialize sample van data silently (without notifyListeners)
  Future<void> initializeSampleVansSilent() async {
    try {
      debugPrint('üîç Checking if vans already exist in Firestore...');
      
      // First check if any vans exist in Firestore
      final existingVans = await _bookingService.getActiveVans();
      
      if (existingVans.isNotEmpty) {
        debugPrint('‚úÖ Found ${existingVans.length} existing vans in Firestore, skipping sample data creation');
        return; // Don't create sample data if real vans exist
      }
      
      debugPrint('üìù No vans found, checking if sample data should be created...');
      
      // Only create sample data if explicitly needed for development
      // In production, this should be disabled
      const bool shouldCreateSampleVans = false; // Set to false to prevent sample data
      
      if (!shouldCreateSampleVans) {
        debugPrint('‚è≠Ô∏è Sample van creation disabled');
        return;
      }
      
      // Sample van creation code here (only runs if enabled)
      debugPrint('üìù Creating sample van data...');
      await _bookingService.initializeSampleVans();
      // Don't call loadVans() here to avoid notifyListeners
      debugPrint('‚úÖ Sample vans initialized successfully');
      
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error initializing sample vans: $e');
    }
  }

  /// Update van occupancy
  Future<void> updateVanOccupancy(String vanId, int occupancy) async {
    try {
      await _bookingService.updateVanOccupancy(vanId, occupancy);
      await loadVans(); // Refresh van data
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error updating van occupancy: $e');
      notifyListeners();
    }
  }

  /// Update van status
  Future<void> updateVanStatus(String vanId, String status) async {
    try {
      await _bookingService.updateVanStatus(vanId, status);
      await loadVans(); // Refresh van data
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error updating van status: $e');
      notifyListeners();
    }
  }
}