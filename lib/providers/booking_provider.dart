import 'package:flutter/foundation.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/booking_models.dart';
import '../services/firebase_booking_service.dart';

class BookingProvider with ChangeNotifier {
  final FirebaseBookingService _bookingService = FirebaseBookingService();
  final FirebaseAuth _auth = FirebaseAuth.instance;

  List<Booking> _bookings = [];
  List<Booking> _filteredBookings = [];
  List<Route> _routes = [];
  List<Van> _vans = [];
  bool _isLoading = false;
  String _searchQuery = '';
  String? _errorMessage;
  Route? _selectedRoute; // NEW: Track the selected route

  List<Booking> get bookings => _filteredBookings;
  List<Route> get routes => _routes;
  List<Van> get vans => _vans;
  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;
  String? get errorMessage => _errorMessage;
  Route? get selectedRoute => _selectedRoute; // NEW: Getter for selected route

  /// Load user's bookings from Firebase
  Future<void> loadBookings() async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final user = _auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      _bookings = await _bookingService.getUserBookings(user.uid);
      _filteredBookings = List.from(_bookings);
      _applySearch();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error loading bookings: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Load available routes from Firebase
  Future<void> loadRoutes() async {
    try {
      _routes = await _bookingService.getAvailableRoutes();
      notifyListeners();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error loading routes: $e');
      notifyListeners();
    }
  }

  /// Create a new booking
  Future<String> createBooking({
    required String routeId,
    required String routeName,
    required String origin,
    required String destination,
    required DateTime departureTime,
    required List<String> seatIds,
    required double basePrice,
    required double discountAmount,
    required double totalAmount,
    required String paymentMethod,
    PaymentStatus? paymentStatus, // Add optional payment status parameter
    Map<String, dynamic>? passengerDetails,
  }) async {
    try {
      _isLoading = true;
      _errorMessage = null;
      notifyListeners();

      final user = _auth.currentUser;
      if (user == null) {
        throw Exception('User not authenticated');
      }

      // Get the active van for this route
      final activeVan = await _bookingService.getActiveVanForRoute(routeId);
      if (activeVan == null) {
        throw Exception('No active van available for this route');
      }

      // Check seat availability for the specific van
      final seatsAvailable = await _bookingService.areSeatsAvailable(
        routeId,
        seatIds,
        activeVan.plateNumber,
        activeVan.driver.name,
      );
      if (!seatsAvailable) {
        throw Exception('One or more selected seats are no longer available');
      }

      // Extract passenger email from passengerDetails or fallback to user email
      final passengerEmail = passengerDetails?['email'] as String? ?? user.email ?? '';
      final passengerName = passengerDetails?['name'] as String? ?? user.displayName ?? 'User';

        // Determine initial booking status: pending if discounted, else confirmed
        final bool hasDiscount = (discountAmount != null && discountAmount > 0) ||
          (passengerDetails != null &&
            (passengerDetails['discountedSeats'] as List?)?.isNotEmpty == true);

        final booking = Booking(
        id: '', // Will be generated by Firebase
        userId: user.uid,
        userName: passengerName, // Use passenger name from form
        userEmail: passengerEmail, // Use passenger email from form
        routeId: routeId,
        routeName: routeName,
        origin: origin,
        destination: destination,
        departureTime: departureTime,
        bookingDate: DateTime.now(),
        seatIds: seatIds,
        numberOfSeats: seatIds.length,
        basePrice: basePrice,
        discountAmount: discountAmount,
        totalAmount: totalAmount,
        paymentMethod: paymentMethod,
        paymentStatus:
          paymentStatus ??
          PaymentStatus.pending, // Use provided status or default to pending
        bookingStatus: hasDiscount ? BookingStatus.pending : BookingStatus.confirmed,
        passengerDetails: passengerDetails,
        vanPlateNumber: activeVan.plateNumber,
        vanDriverName: activeVan.driver.name,
        vanDriverContact: activeVan.driver.contact,
      );

      final bookingId = await _bookingService.createBooking(booking);

      // Reload bookings to reflect the new booking
      await loadBookings();

      return bookingId;
    } catch (e) {
      _errorMessage = e.toString();
      notifyListeners();
      throw Exception('Failed to create booking: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Cancel booking
  Future<void> cancelBooking(String bookingId) async {
    try {
      _isLoading = true;
      _errorMessage = null;
      notifyListeners();

      await _bookingService.cancelBooking(bookingId);

      // Reload bookings to reflect the cancellation
      await loadBookings();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error cancelling booking: $e');
      notifyListeners();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Update payment status
  Future<void> updatePaymentStatus(
    String bookingId,
    PaymentStatus status,
  ) async {
    try {
      await _bookingService.updatePaymentStatus(bookingId, status);

      // Update local booking
      final bookingIndex = _bookings.indexWhere((b) => b.id == bookingId);
      if (bookingIndex != -1) {
        // Reload bookings to get updated data
        await loadBookings();
      }
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error updating payment status: $e');
      notifyListeners();
    }
  }

  /// Get vans currently boarding for a specific route
  Future<List<Van>> getBoardingVans(String routeId) async {
    try {
      final vans = await _bookingService.getVansByStatus('boarding');
      // Filter by routeId when provided
      final filtered = vans.where((v) => v.currentRouteId == routeId).toList();
      return filtered;
    } catch (e) {
      debugPrint('Error fetching boarding vans: $e');
      rethrow;
    }
  }

  /// Rebook a failed booking to a specific van (creates a new booking)
  Future<String> rebookFailedBooking(Booking booking, Van van) async {
    try {
      _isLoading = true;
      _errorMessage = null;
      notifyListeners();

      // Enforce same-day rebooking: user can only rebook on the same calendar day
      final now = DateTime.now();
      final original = booking.bookingDate.toLocal();
      if (!(original.year == now.year && original.month == now.month && original.day == now.day)) {
        throw Exception('Rebooking is allowed only on the same day as the original booking');
      }

      // Determine status based on discounts
      final bool hasDiscount = (booking.discountAmount != null && booking.discountAmount > 0) ||
          (booking.passengerDetails != null &&
              (booking.passengerDetails!['discountedSeats'] as List?)?.isNotEmpty == true);

      final newBooking = Booking(
        id: '',
        userId: booking.userId,
        userName: booking.userName,
        userEmail: booking.userEmail,
        routeId: booking.routeId,
        routeName: booking.routeName,
        origin: booking.origin,
        destination: booking.destination,
        departureTime: booking.departureTime,
        bookingDate: DateTime.now(),
        seatIds: booking.seatIds,
        numberOfSeats: booking.numberOfSeats,
        basePrice: booking.basePrice,
        discountAmount: booking.discountAmount,
        totalAmount: booking.totalAmount,
        paymentMethod: booking.paymentMethod,
        paymentStatus: booking.paymentStatus,
        bookingStatus: hasDiscount ? BookingStatus.pending : BookingStatus.confirmed,
        passengerDetails: booking.passengerDetails,
        vanPlateNumber: van.plateNumber,
        vanDriverName: van.driver.name,
        vanDriverContact: van.driver.contact,
      );

      final newId = await _bookingService.createBooking(newBooking);

      // Refresh bookings
      await loadBookings();

      return newId;
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error rebooking failed booking: $e');
      throw Exception('Failed to rebook: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Search bookings
  void searchBookings(String query) {
    _searchQuery = query;
    _applySearch();
    notifyListeners();
  }

  void _applySearch() {
    if (_searchQuery.isEmpty) {
      _filteredBookings = List.from(_bookings);
    } else {
      _filteredBookings = _bookings.where((booking) {
        return booking.userName.toLowerCase().contains(
              _searchQuery.toLowerCase(),
            ) ||
            booking.userEmail.toLowerCase().contains(
              _searchQuery.toLowerCase(),
            ) ||
            booking.origin.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            booking.destination.toLowerCase().contains(
              _searchQuery.toLowerCase(),
            ) ||
            booking.routeName.toLowerCase().contains(
              _searchQuery.toLowerCase(),
            ) ||
            booking.id.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            (booking.eTicketId?.toLowerCase().contains(
                  _searchQuery.toLowerCase(),
                ) ??
                false);
      }).toList();
    }
  }

  /// Get booking by ID
  Future<Booking?> getBookingById(String bookingId) async {
    try {
      return await _bookingService.getBookingById(bookingId);
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error getting booking: $e');
      notifyListeners();
      return null;
    }
  }

  /// Check if seats are available
  Future<bool> areSeatsAvailable(String routeId, List<String> seatIds) async {
    try {
      // Get the active van for this route
      final activeVan = await _bookingService.getActiveVanForRoute(routeId);
      if (activeVan == null) {
        return false; // No active van means no seats available
      }

      return await _bookingService.areSeatsAvailable(
        routeId,
        seatIds,
        activeVan.plateNumber,
        activeVan.driver.name,
      );
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error checking seat availability: $e');
      notifyListeners();
      return false;
    }
  }

  /// Initialize sample data (for testing)
  Future<void> initializeSampleData() async {
    try {
      await _bookingService.initializeSampleData();
      // Load routes without notifyListeners to avoid setState during build
      _routes = await _bookingService.getAvailableRoutes();
      debugPrint('Sample data initialized successfully');
      notifyListeners();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error initializing sample data: $e');
      notifyListeners();
    }
  }

  /// Initialize sample data silently (without notifyListeners)
  Future<void> initializeSampleDataSilent() async {
    try {
      await _bookingService.initializeSampleData();
      // Load routes without notifyListeners to avoid setState during build
      _routes = await _bookingService.getAvailableRoutes();
      debugPrint('Sample data initialized successfully');
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error initializing sample data: $e');
    }
  }

  /// Clear error message
  void clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  /// Select a route and load vans for that route
  Future<void> selectRoute(Route route) async {
    try {
      debugPrint('üìç Route selected: ${route.name} (ID: ${route.id})');
      _selectedRoute = route;
      notifyListeners();
      
      // Load vans for this specific route
      await loadVansForRoute(route.id);
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error selecting route: $e');
      notifyListeners();
    }
  }

  /// Load vans for a specific route
  Future<void> loadVansForRoute(String routeId) async {
    try {
      _isLoading = true;
      notifyListeners();

      debugPrint('üöê Loading vans for route: $routeId');
      
      // Get all vans from Firestore
      final allVans = await _bookingService.getAllVans();
      
      // Filter to show only vans assigned to this route AND in boarding status
      _vans = allVans.where((van) {
        final isCorrectRoute = van.currentRouteId == routeId;
        final isBoarding = van.status.toLowerCase() == 'boarding';
        final isActive = van.isActive;
        
        debugPrint('  Van ${van.plateNumber}: route=${van.currentRouteId} (match: $isCorrectRoute), status=${van.status} (boarding: $isBoarding), active=$isActive');
        
        return isCorrectRoute && isBoarding && isActive;
      }).toList();
      
      debugPrint('‚úÖ Found ${_vans.length} boarding vans for route $routeId');
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error loading vans for route: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Van Management Methods

  /// Load active vans from Firebase
  Future<void> loadVans() async {
    try {
      debugPrint('üîç Loading vans from Firestore...');
      _isLoading = true;
      notifyListeners();

      // Clear existing vans first to avoid showing stale data
      _vans.clear();

      final loadedVans = await _bookingService.getActiveVans();
      debugPrint('üìÑ Loaded ${loadedVans.length} vans from Firestore');

      // Debug print to see loaded vans
      for (var van in loadedVans) {
        debugPrint(
          'üöê Van: ${van.plateNumber} - Driver: ${van.driver.name} - Raw Status: "${van.status}" - Display: "${van.statusDisplay}" - Queue: ${van.queuePosition} (${van.currentOccupancy}/${van.capacity})',
        );
      }

      _vans = loadedVans;
      _isLoading = false;
      debugPrint('‚úÖ Successfully loaded ${_vans.length} vans from Firestore');

      notifyListeners();
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error loading vans: $e');
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Initialize sample van data
  Future<void> initializeSampleVans() async {
    try {
      debugPrint('üîç Checking if vans already exist in Firestore...');

      // First check if any vans exist in Firestore
      final existingVans = await _bookingService.getActiveVans();

      if (existingVans.isNotEmpty) {
        debugPrint(
          '‚úÖ Found ${existingVans.length} existing vans in Firestore, skipping sample data creation',
        );
        return; // Don't create sample data if real vans exist
      }

      debugPrint(
        'üìù No vans found, checking if sample data should be created...',
      );

      // Only create sample data if explicitly needed for development
      // In production, this should be disabled
      const bool shouldCreateSampleVans =
          false; // Set to false to prevent sample data

      if (!shouldCreateSampleVans) {
        debugPrint('‚è≠Ô∏è Sample van creation disabled');
        return;
      }

      // Sample van creation code here (only runs if enabled)
      debugPrint('üìù Creating sample van data...');
      await _bookingService.initializeSampleVans();
      await loadVans();
      debugPrint('‚úÖ Sample vans initialized successfully');
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error initializing sample vans: $e');
    }
  }

  /// Initialize sample van data silently (without notifyListeners)
  Future<void> initializeSampleVansSilent() async {
    try {
      debugPrint('üîç Checking if vans already exist in Firestore...');

      // First check if any vans exist in Firestore
      final existingVans = await _bookingService.getActiveVans();

      if (existingVans.isNotEmpty) {
        debugPrint(
          '‚úÖ Found ${existingVans.length} existing vans in Firestore, skipping sample data creation',
        );
        return; // Don't create sample data if real vans exist
      }

      debugPrint(
        'üìù No vans found, checking if sample data should be created...',
      );

      // Only create sample data if explicitly needed for development
      // In production, this should be disabled
      const bool shouldCreateSampleVans =
          false; // Set to false to prevent sample data

      if (!shouldCreateSampleVans) {
        debugPrint('‚è≠Ô∏è Sample van creation disabled');
        return;
      }

      // Sample van creation code here (only runs if enabled)
      debugPrint('üìù Creating sample van data...');
      await _bookingService.initializeSampleVans();
      // Don't call loadVans() here to avoid notifyListeners
      debugPrint('‚úÖ Sample vans initialized successfully');
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error initializing sample vans: $e');
    }
  }

  /// Update van occupancy
  Future<void> updateVanOccupancy(String vanId, int occupancy) async {
    try {
      await _bookingService.updateVanOccupancy(vanId, occupancy);
      await loadVans(); // Refresh van data
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error updating van occupancy: $e');
      notifyListeners();
    }
  }

  /// Update van status
  Future<void> updateVanStatus(String vanId, String status) async {
    try {
      await _bookingService.updateVanStatus(vanId, status);
      await loadVans(); // Refresh van data
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('Error updating van status: $e');
      notifyListeners();
    }
  }

  /// Sync vans to available routes - ensures all vans have correct currentRouteId
  /// If routeId is provided, syncs all vans to that specific route
  Future<void> syncVansToRoutes({String? routeId}) async {
    try {
      debugPrint('üîÑ Syncing vans to available routes...');
      await _bookingService.syncVansToAvailableRoute(specificRouteId: routeId);
      await loadVans(); // Refresh van data after sync
      debugPrint('‚úÖ Vans synced to routes successfully');
    } catch (e) {
      _errorMessage = e.toString();
      debugPrint('‚ùå Error syncing vans to routes: $e');
      // Don't throw - this is not critical for app functionality
    }
  }
}
